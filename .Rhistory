warning("输入不是数值向量")
return(NA)
}
# 移除NA值
x_clean <- na.omit(x)
# 检查有效样本量
if(length(x_clean) < 20) {
warning("有效样本量不足(<20)")
return(NA)
}
# 检查唯一值数目（修正括号位置）
if(length(unique(x_clean)) < 10) {
warning("唯一值数目过少(<10)，当前唯一值数目 = ", length(unique(x_clean)))
return(NA)
}
# 计算统计量
s <- abs(skewness(x_clean))
k <- abs(kurtosis(x_clean) - 3)
# 返回结果列表
list(
Skewness = s,
Kurtosis = k + 3,  # 显示原始峰度值
Approx_Normal = s < 2 & k < 4,
N_Valid = length(x_clean),
N_NA = length(x) - length(x_clean)
)
}
# 对每一列应用评估函数
norm_results <- lapply(x, is_approximately_normal)
# 整理结果为数据框
result_df <- do.call(rbind, lapply(norm_results, function(x) {
if(is.list(x)) {
data.frame(
Skewness = x$Skewness,
Kurtosis = x$Kurtosis,
Is_Normal = x$Approx_Normal,
Valid_N = x$N_Valid,
NA_Count = x$N_NA
)
} else {
data.frame(
Skewness = NA,
Kurtosis = NA,
Is_Normal = NA,
Valid_N = NA,
NA_Count = NA
)
}
}))
print(result_df)
category <- rownames(result_df[is.na(result_df$Is_Normal),])
normal_distribution <- rownames(result_df[result_df$Is_Normal=="TRUE"&
!is.na(result_df$Is_Normal),])
n_normal_distribution <- rownames(result_df[result_df$Is_Normal=="FALSE"&
!is.na(result_df$Is_Normal),])
category
normal_distribution
n_normal_distribution
#减掉normal_distribution中的"Die_permth_int"
normal_distribution<-normal_distribution[-which(normal_distribution=="Die_permth_int")]
n_normal_distribution<-c(n_normal_distribution,"Die_permth_int")
##### 纳入分析的和不纳入分析的患者进行基线对比 ######
dt1$datac <- ifelse(dt1$seqn %in% data$seqn, "Included", "Excluded")
table(dt1$datac)
truncate_1n99 <- function (x) {
lower <- quantile(x, 0.001, na.rm= T)
upper <- quantile(x, 0.999, na.rm= T)
x_1n99 <- ifelse(x>upper, upper, ifelse(x<lower,lower,x)) #在此处进行调整
x_1n99
}
all_vars <- setdiff(c(normal_distribution, n_normal_distribution), "Die_permth_int")
data <- data %>%
mutate(across(all_of(all_vars),
list(`999` = ~truncate_1n99(.))))
all_vars_999 <-paste0(all_vars,"_999")
## 应用
batch_results <- uni_analysis(
data,
vars = c("dex_SII.q4",all_vars_999,category),
outcome = "Die_mortstat",
time_var = "Die_permth_int",
effect_digits = 2,
p_digits = 3,
full = T,
event = T
)
## 应用
batch_results <- yyds_uni_analysis(
data,
vars = c("dex_SII.q4",all_vars_999,category),
outcome = "Die_mortstat",
time_var = "Die_permth_int",
effect_digits = 2,
p_digits = 3,
full = T,
event = T
)
View(batch_results)
# 偏度/峰度经验法则
z <- yyds_type(x)
category
normal_distribution
n_normal_distribution
z$variable_types$categorical
z$variable_types$normal
z$variable_types$non_normal
devtools::document()
devtools::build()
devtools::install()
devtools::document()
devtools::build()
devtools::document()
devtools::document()
devtools::build()
devtools::install()
devtools::document()
devtools::build()
devtools::install()
devtools::document()
devtools::build()
devtools::install()
devtools::document()
devtools::build()
devtools::install()
devtools::document()
devtools::build()
devtools::install()
devtools::document()
warnings()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::build()
devtools::install()
?ols
??ols
devtools::document()
devtools::build()
devtools::install()
devtools::document()
devtools::build()
devtools::install()
devtools::document()
devtools::build()
devtools::install()
devtools::document()
devtools::build()
devtools::document()
devtools::build()
devtools::install()
#'
#' # 线性回归
#' fit <- lm(mpg ~ wt + factor(cyl), data = mtcars)
#' yyds_pfortrend(fit, "wt")
#'
#' # 逻辑回归
#' fit <- glm(vs ~ mpg + gear, data = mtcars, family = binomial)
#' yyds_pfortrend(fit, "mpg")
#' }
#'
yyds_pfortrend <- function(fit, var) {
# 检查模型类型
supported_models <- c("coxph", "glm", "lm", "svyglm", "svycoxph")
if (!inherits(fit, supported_models)) {
stop("模型类型不支持！支持的类型：", paste(supported_models, collapse = ", "))
}
# 提取模型数据
data <- model.frame(fit)
if (!var %in% colnames(data)) {
stop("变量 ", var, " 不在模型中！")
}
# 检查变量是否为连续变量或仅有两个取值（二分类变量）
var_data <- data[[var]]
unique_vals <- unique(na.omit(var_data))
n_unique <- length(unique_vals)
if (n_unique <= 2) {
message("变量 '", var, "' 为二分类变量，无需进行趋势检验。")
return(NA)
}
# 强制变量为数值（无论原始类型）
data[[var]] <- as.numeric(data[[var]])
# 重新拟合模型（确保变量作为连续变量）
formula_original <- formula(fit)
formula_new <- update(formula_original, as.formula(paste(". ~ . -", var, "+ as.numeric(", var, ")")))
fit_new <- update(fit, formula = formula_new)
# 提取趋势P值
coef_table <- summary(fit_new)$coefficients
var_numeric <- paste0("as.numeric(", var, ")")
# 处理不同模型类型的行名差异
row_names <- rownames(coef_table)
# 检查可能的变量名形式 (glm可能不保留as.numeric()包装)
possible_names <- c(var_numeric, var)
# 找到实际使用的变量名
matched_name <- possible_names[possible_names %in% row_names]
if (length(matched_name) == 0) {
stop("变量 ", var, " 的系数不存在，可能模型未正确拟合。可用变量: ",
paste(row_names, collapse = ", "))
}
p_col <- ifelse(inherits(fit, c("lm", "glm")) && family(fit)$family == "gaussian",
"Pr(>|t|)", "Pr(>|z|)")
p_trend <- coef_table[matched_name[1], p_col]
pfortrend <- ifelse(p_trend < 0.001, "<0.001", sprintf("%.4f", p_trend))
print(paste0("p for trend: ", pfortrend))
return(pfortrend)
}
devtools::document()
devtools::build()
devtools::install()
devtools::document()
devtools::build()
devtools::install()
devtools::document()
devtools::build()
devtools::install()
devtools::document()
devtools::build()
devtools::install()
devtools::document()
devtools::build()
devtools::document()
devtools::build()
devtools::install()
devtools::document()
devtools::build()
devtools::install()
devtools::document()
devtools::build()
devtools::install()
devtools::document()
devtools::build()
devtools::install()
devtools::document()
devtools::build()
devtools::install()
devtools::document()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::document()
library(devtools)
library(usethis)
library(roxygen2)
devtools::document()
devtools::document()
devtools::build()
library(devtools)
library(usethis)
library(roxygen2)
devtools::document()
devtools::build()
library(devtools)
library(usethis)
library(roxygen2)
devtools::document()
devtools::build()
library(devtools)
library(usethis)
library(roxygen2)
devtools::document()
devtools::build()
library(devtools)
library(usethis)
library(roxygen2)
devtools::document()
devtools::build()
library(devtools)
library(usethis)
library(roxygen2)
devtools::document()
devtools::build()
#' 快速合并多列数据
#'
#' 根据指定的列名模式合并数据框中的多列，使用dplyr::coalesce函数优先选择非NA值。
#'
#' @param data 要处理的数据框
#' @param key_chr 要合并的列名中包含的关键字符（后缀、前缀或中间部分），默认为c("_a", "_b", "_c")
#' @param pattern 匹配模式，可选："ends_with"（后缀匹配）、"starts_with"（前缀匹配）或"contains"（包含匹配），默认为"ends_with"
#' @param new_suffix 新列名的后缀，如果为NULL则使用基础名
#' @param valid_var 用于验证合并结果的变量名（通常是ID变量），如果提供则会输出合并统计信息
#' @param remove_original 是否移除原始列，默认为TRUE
#' @param verbose 是否显示详细过程信息，默认为FALSE
#'
#' @return 返回处理后的数据框，包含合并后的新列（可能已移除原始列）
#'
#' @export
yyds_coalesce <- function(data,
key_chr = c("_a", "_b", "_c"),
pattern = c("ends_with", "starts_with", "contains"),
new_suffix = NULL,
valid_var = NULL,
remove_original = TRUE,
verbose = FALSE) {
# 参数检查
if (!is.data.frame(data)) stop("data must be a data frame")
if (length(key_chr) < 2) stop("key_chr must have ≥2 elements")
pattern <- match.arg(pattern)
if (!is.null(valid_var) && !valid_var %in% names(data))
stop(paste("Validation variable", valid_var, "not found in data"))
# 内部函数：转义正则表达式特殊字符
esc <- function(x) gsub("([][{}()+*^$|\\\\?.])", "\\\\\\1", x)
# 构建正则表达式模式
regex_pattern <- switch(pattern,
ends_with = paste0("(", paste(esc(key_chr), collapse = "|"), ")$"),
starts_with = paste0("^(", paste(esc(key_chr), collapse = "|"), ")"),
contains = paste0("(", paste(esc(key_chr), collapse = "|"), ")")
)
# 匹配列名
matched_cols <- grep(regex_pattern, names(data), value = TRUE)
if (length(matched_cols) == 0) {
if (verbose) message("No columns matched the pattern")
return(data)
}
# 提取基础列名
base_names <- switch(pattern,
ends_with = sub(paste0("(", paste(esc(key_chr), collapse = "|"), ")$"), "", matched_cols),
starts_with = sub(paste0("^(", paste(esc(key_chr), collapse = "|"), ")"), "", matched_cols),
contains = vapply(matched_cols, function(x) {
for (k in key_chr) if (grepl(esc(k), x)) return(sub(esc(k), "", x))
x
}, FUN.VALUE = character(1))
)
# 主处理循环
new_cols_created <- character(0)
for (base in unique(base_names[duplicated(base_names)])) {
cols_to_merge <- matched_cols[base_names == base]
first_subcol <- cols_to_merge[which.min(match(cols_to_merge, names(data)))]
new_col <- if (!is.null(new_suffix)) paste0(base, new_suffix) else base
if (verbose) message("Merging: ", paste(cols_to_merge, collapse = " + "), " → ", new_col)
# 创建合并列
data <- dplyr::mutate(
data,
!!new_col := dplyr::coalesce(!!!rlang::syms(cols_to_merge))
)
new_cols_created <- c(new_cols_created, new_col)
# 调整列位置
data <- dplyr::relocate(data, !!new_col, .before = dplyr::all_of(first_subcol))
# 验证输出
if (!is.null(valid_var)) {
if (verbose) {
validation <- data %>%
dplyr::group_by(.data[[valid_var]]) %>%
dplyr::summarise(
dplyr::across(all_of(cols_to_merge), ~ sum(!is.na(.x))),
"{new_col}" := sum(!is.na(.data[[new_col]])),
.groups = "drop"
)
cat(crayon::silver("\nValidation for ", new_col, ":\n"))
print(as.data.frame(validation))
}
}
}
# 移除原始列
if (remove_original) {
cols_to_remove <- setdiff(matched_cols, new_cols_created)
if (length(cols_to_remove) > 0) {
data <- dplyr::select(data, -dplyr::all_of(cols_to_remove))
}
}
return(data)
}
#' 快速合并多列数据
#'
#' 根据指定的列名模式合并数据框中的多列，使用dplyr::coalesce函数优先选择非NA值。
#'
#' @param data 要处理的数据框
#' @param key_chr 要合并的列名中包含的关键字符（后缀、前缀或中间部分），默认为c("_a", "_b", "_c")
#' @param pattern 匹配模式，可选："ends_with"（后缀匹配）、"starts_with"（前缀匹配）或"contains"（包含匹配），默认为"ends_with"
#' @param new_suffix 新列名的后缀，如果为NULL则使用基础名
#' @param valid_var 用于验证合并结果的变量名（通常是ID变量），如果提供则会输出合并统计信息
#' @param remove_original 是否移除原始列，默认为TRUE
#'
#' @return 返回处理后的数据框，包含合并后的新列（可能已移除原始列）
#'
#' @details
#' 该函数主要用于处理具有相同变量但来自不同来源的数据（如调查数据中的多波次测量）。
#' 它会自动识别具有相同基础变量名但不同后缀/前缀的列，并使用dplyr::coalesce合并它们。
#' 合并列位于第一个子列之前，便于后续分析。
#'
#' @examples
#' \dontrun{
#' # 示例数据
#' df <- data.frame(
#'   id = 1:5,
#'   score_a = c(1, NA, 3, NA, 5),
#'   score_b = c(NA, 2, 3, 4, NA),
#'   value_x = c(10, NA, 30, NA, NA),
#'   value_y = c(NA, 20, NA, 40, 50)
#' )
#'
#' # 合并以后缀_a和_b结尾的列
#' yyds_coalesce(df, key_chr = c("_a", "_b"), pattern = "ends_with")
#'
#' # 合并并保留原始列，添加"_merged"后缀
#' yyds_coalesce(df, key_chr = c("_a", "_b"), pattern = "ends_with",
#'               new_suffix = "_merged", remove_original = FALSE)
#'
#' # 合并并验证结果（使用id列作为验证变量）
#' yyds_coalesce(df, key_chr = c("_a", "_b"), pattern = "ends_with",
#'               valid_var = "id")
#' }
#'
#' @importFrom dplyr coalesce
#' @importFrom crayon red
#' @export
yyds_coalesce <- function(data,
key_chr = c("_a", "_b", "_c"),
pattern = c("ends_with", "starts_with", "contains"),
new_suffix = NULL,
valid_var  = NULL,
remove_original = TRUE) {
# -------- 参数检查 --------
if (!is.data.frame(data))           stop("data must be a data frame")
if (length(key_chr) < 2)            stop("key_chr must have ≥2 elements")
pattern <- match.arg(pattern)
if (!is.null(valid_var) && !valid_var %in% names(data))
stop(paste("Validation variable", valid_var, "not found in data"))
# -------- 内部工具 --------
esc <- function(x) gsub("([][{}()+*^$|\\\\?.])", "\\\\\\1", x)
regex_pattern <- switch(pattern,
ends_with   = paste0("(", paste(esc(key_chr), collapse = "|"), ")$"),
starts_with = paste0("^(", paste(esc(key_chr), collapse = "|"), ")"),
contains    = paste0("(", paste(esc(key_chr), collapse = "|"), ")")
)
matched_cols <- grep(regex_pattern, names(data), value = TRUE)
if (length(matched_cols) == 0) return(data)    # 没匹配直接返回
base_names <- switch(pattern,
ends_with   = sub(paste0("(", paste(esc(key_chr), collapse = "|"), ")$"), "", matched_cols),
starts_with = sub(paste0("^(", paste(esc(key_chr), collapse = "|"), ")"), "", matched_cols),
contains    = vapply(matched_cols, function(x) {
for (k in key_chr) if (grepl(esc(k), x)) return(sub(esc(k), "", x))
x
}, FUN.VALUE = character(1))
)
# -------- 主循环 --------
for (base in unique(base_names[duplicated(base_names)])) {
cols_to_merge <- matched_cols[base_names == base]
first_subcol  <- cols_to_merge[which.min(match(cols_to_merge, names(data)))]
new_col       <- if (!is.null(new_suffix)) paste0(base, new_suffix) else base
# 1) 生成新列
data <- dplyr::mutate(
data,
!!new_col := dplyr::coalesce(!!!rlang::syms(cols_to_merge))
)
# 2) 把新列挪到第一子列前
data <- dplyr::relocate(data, !!new_col, .before = dplyr::all_of(first_subcol))
# 3) 打印验证信息（仅打印，不写回 data）
if (!is.null(valid_var)) {
validation <- data %>%
dplyr::group_by(.data[[valid_var]]) %>%
dplyr::summarise(
dplyr::across(all_of(cols_to_merge), ~ sum(!is.na(.x))),
# "{new_col}" := sum(!is.na(.data[[new_col]])),
.groups = "drop"
)
cat(crayon::red("\n", new_col, "\n"))
print(as.data.frame(validation))
}
# 4) 删除旧列
if (remove_original) {
data <- dplyr::select(data, -dplyr::all_of(cols_to_merge))
}
}
data
}
library(devtools)
library(usethis)
library(roxygen2)
devtools::document()
devtools::build()
library(devtools)
library(usethis)
library(roxygen2)
devtools::document()
devtools::build()
library(devtools)
library(usethis)
library(roxygen2)
devtools::document()
devtools::build()
library(devtools)
library(usethis)
library(roxygen2)
devtools::document()
devtools::build()
library(devtools)
library(usethis)
library(roxygen2)
devtools::document()
devtools::build()
library(devtools)
library(usethis)
library(roxygen2)
devtools::document()
devtools::build()
library(devtools)
library(usethis)
library(roxygen2)
devtools::document()
devtools::build()
library(devtools)
library(usethis)
library(roxygen2)
devtools::document()
devtools::build()
library(devtools)
library(usethis)
library(roxygen2)
devtools::document()
devtools::build()

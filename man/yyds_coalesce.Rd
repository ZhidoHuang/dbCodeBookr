% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/yyds_coalesce.R
\name{yyds_coalesce}
\alias{yyds_coalesce}
\title{快速合并多列数据}
\usage{
yyds_coalesce(
  data,
  key_chr = c("_a", "_b", "_c"),
  pattern = c("ends_with", "starts_with", "contains"),
  new_suffix = NULL,
  valid_var = NULL,
  remove_original = TRUE
)
}
\arguments{
\item{data}{要处理的数据框}

\item{key_chr}{要合并的列名中包含的关键字符（后缀、前缀或中间部分），默认为c("_a", "_b", "_c")}

\item{pattern}{匹配模式，可选："ends_with"（后缀匹配）、"starts_with"（前缀匹配）或"contains"（包含匹配），默认为"ends_with"}

\item{new_suffix}{新列名的后缀，如果为NULL则使用基础名}

\item{valid_var}{用于验证合并结果的变量名（通常是ID变量），如果提供则会输出合并统计信息}

\item{remove_original}{是否移除原始列，默认为TRUE}
}
\value{
返回处理后的数据框，包含合并后的新列（可能已移除原始列）
}
\description{
根据指定的列名模式合并数据框中的多列，使用dplyr::coalesce函数优先选择非NA值。
}
\details{
该函数主要用于处理具有相同变量但来自不同来源的数据（如调查数据中的多波次测量）。
它会自动识别具有相同基础变量名但不同后缀/前缀的列，并使用dplyr::coalesce合并它们。
}
\examples{
\dontrun{
# 示例数据
df <- data.frame(
  id = 1:5,
  score_a = c(1, NA, 3, NA, 5),
  score_b = c(NA, 2, 3, 4, NA),
  value_x = c(10, NA, 30, NA, NA),
  value_y = c(NA, 20, NA, 40, 50)
)

# 合并以后缀_a和_b结尾的列
yyds_coalesce(df, key_chr = c("_a", "_b"), pattern = "ends_with")

# 合并并保留原始列，添加"_merged"后缀
yyds_coalesce(df, key_chr = c("_a", "_b"), pattern = "ends_with",
              new_suffix = "_merged", remove_original = FALSE)

# 合并并验证结果（使用id列作为验证变量）
yyds_coalesce(df, key_chr = c("_a", "_b"), pattern = "ends_with",
              valid_var = "id")
}

}
